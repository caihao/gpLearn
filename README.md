# GPLearn

## 介绍
GPLearn是我们针对切伦科夫望远镜所独立编写的程序包，基于python语言和pytorch模型，我们将不同的功能单独打包成相对应的模块，并允许用户根据需求自定义模块参数。
通过GPLearn进行的一系列数据模拟与分析的相关结果详见，读者不仅可以利用我们提供的数据还原文章中展示的结果，同时也可以用于实际探测器的数据分析，我们希望这一结果可以被广泛用于天文物理领域。<br><br>

## 更新日志
1. stable-1.1.0 (最新版本，更新于2023.07.28 UTC+8)
+ 增加了训练结果中的各项标准差，并允许在结果绘图中加入误差显示
+ 增加了角度回归预测的功能，现在可以直接通过直接定义 **train_type** 为 **angle** 开展相关训练；此外，角度训练采用的数据集更为繁重、模型更为复杂；请注意，当前版本使用的数据集和模型尚处于测试阶段，得到的结果不代表最终品质
+ 新增了数据集缓存功能，大幅缩短重复训练时数据加载所消耗的时间，您可以在 **settings.json** 文件中更改相应设置 **tempData**
2. stable-1.0.2 (更新于2023.07.18 UTC+8)
+ 修复了读取 **settings.json** 文件无法同步的相关问题
3. stable-1.0.1 (更新于2023.07.17 UTC+8)
+ 修复了日志版本信息显示异常的相关问题
4. stable-1.0.0 (更新于2023.07.16 UTC+8)
+ 正式版本现在可以使用
<br><br>

## 软件架构
为了您可以正常使用GPLearn，请确保您在当前环境下安装了以下依赖：
1. python  ^3.8.5<br>
2. pytorch  ^1.7.0<br>
3. torchvision  ^0.8.0<br>
4. matplotlib  ^3.4.0 <br>
5. numpy  ^1.22.2<br>
6. pandas  ^1.2.4<br><br>

## 安装教程
1. 在您指定的位置上运行如下克隆命令：<br><center>**git clone https://gitee.com/chengaoyan/gplearn.git**</center>
2. 如果您是首次下载使用，请首先运行位于程序住目录下的 **init.py** 文件，该脚本会检查程序主路径下的 **/data** 目录及其子目录是否完整（如不完整则会创建补全）
3. 位于程序主目录下的 **main.py** 文件是作业脚本，您可以根据您的不同需求在其中设定程序的执行流程，一些参数的调整可能需要您改动 **settings.json** 文件，具体方法将在以下部分详细阐述。此外，**main_quick_start.py** 提供了适用于背景抑制工作的简单演示程序，您可以直接运行
4. 我们更推荐您使用 **nohup** 命令在超算服务器上托管运行，为此，我们编写了适配的日志功能与剩余时间预测功能，您的所有输出结果（包括所有中间结果）都将被自动保存
<br><br>

## 使用说明
### 准备工作
为了可以正确运行GPLearn，请确保您的计算机上安装了python以及对应版本的依赖。如果您是首次使用，请首先运行程序包根目录下的init.py脚本，这将会自动检查您的程序目录完整性并自动补齐缺失的文件。<center> **python init.py** </center>

**/data/origin** 包含着不同能量下光子与质子的探测器数据。考虑到程序包整体的大小以及程序的完整性，我们在正式版本中附带了部分demo数据，这将使您的程序可以正常运行。此外您可以参考我们的数据格式，将您数据作相应修改并用于GPLearn。
<br>
我们推荐的程序主入口是位于GPLearn根目录的 **main.py** 文件，您可以根据需求自定义工作流程。此外，我们提供了一个快如上手脚本，您可以直接运行 **main_quick_start.py** ，并在其基础上作出相应修改。
<br><br>

### 主流工作
为了方便起见，我们将所有的数据加载、创建模型、训练及测试流程统一集成于 **automation** 中，您只需要在程序主入口 **main.py** 将其引入<br><center>**from bin.automation import Au**</center>

在 **Au** 类的初始化中，您需要指定以下内容：
<!-- <center> -->

| 参数 | 类型 | 默认值 | 说明 |
| --- | --- | --- | --- |
| gamma_energy_list | list | - | 必填，表示参与训练的光子能级（请注意，您需要确保在 **/data/origin** 目录下含有相应的原始数据文件） |
| proton_energy_list | list | - | 必填，表示参与训练的质子能级 |
| particle_number_gamma | int | - | 必填，指定每个能量点所要加载的光子数量（请注意，您需要尽可能确保对应的原始数据文件含有足够多的事例数据，否则可能会造成最终加载数量小于设定数量的情况） |
| particle_number_proton | int | - | 必填，指定每个能量点所要加载的光子数量 |
| allow_pic_number_list | list | - | 必填，指定所允许的被激发探测器数量，程序将按照列表中指定的顺序从原始数据集中加载触发了特定数量探测器的事例数据，直至达到所设定的数量或者所有满足条件的数据全部被加载 |
| limit_min_pix_number | bool | False | 是否需要限制激发像素阈值，若为True，程序会读取settings.json中相应设置 |
| ignore_head_number | int | 0 | 设定数据集偏置，指定程序从当前位置加载，即会忽略这个索引之前的数据 |
| interval | float | 0.8 | 设定用于训练的数据占整体数据的比例 |
| batch_size | int | 1 | 设定单次训练样本数量（请注意，如果您在settings.json中设定了多GPU集群计算，请确保此参数设定大于等于2） |
| use_data_type | str | None | 设定用于加载的数据类型（请注意，您需要确保在 **/data/origin** 目录下含有相应的原始数据文件） |
| pic_size | int | 64 | 设定经过剪裁处理后的图片尺寸 |
| centering | bool | True | 设定图像剪裁过程是否将信号区域居中显示在中心区域 |
| use_weight | bool | False | 设定在居中过程中，信号区域中心点的坐标是否按照信号强度加权处理 |
| train_type | str | particle | 设定模型训练任务类型，当前仅支持背景抑制工作（particle）、能量重建任务（energy）、芯位坐标还原（position）、和入射方向还原（angle） |
| need_data_info | bool | False | 设定是否需要训练过程详细数据信息（不同于日志），若为True，程序则会记录训练过程和测试过程中的每次迭代的损失和正确率，以及最后的结果，并保存至 **/data/info** |
| use_loading_process | int | None | 指定多进程加载数据（请注意，当前参数已被禁用，程序强制为单进程加载） |
| current_file_name | str | main.py | 指定主函数的入口文件名，如果您需要在其他文件中执行程序，请改动为相应的文件名 |

<!-- </center> -->
<br>此外，**settings.json** 包含了程序运行的一些设置，这里将介绍它的用法：<br>
1. **loading_min_pix** 模块控制了图像预处理过程中的像素激发阈值，如果在 **Au** 类的初始化中设定参数 **limit_min_pix_number** 为 **True** ，程序则会读取该参数下的相应设置，否则被忽略。
+ 参数 **uniformThreshold** 表示是否使用统一能量阈值，若为 **true** 则会分别对光子使用设定的 **gammaUniform** 阈值，对质子使用设定的 **protonUniform** 阈值；若为 **false** 则会分别读取 **gamma** 和 **proton** 在不同能量点下的相应设定阈值（请注意，此时请确保您设定了相应的能量对应的阈值，否则程序将按照0阈值处理）。
2. **GPU** 模块控制了深度学习所使用的计算设备，对于一般设备，程序将使用主GPU，此时不需额外设置。
+ 对于含有多个GPU的设备，您可以通过更改 **mainGPUIndex** 参数手动设置参与运算的设备编号；此外，您也可以通过开启 **multiple** 参数使得使用多张显卡同时运算，所使用的显卡编号集合可以通过 **multipleGPUIndex** 参数设定（请注意，如果您使用多显卡并行计算，请确保在 **Au** 类的初始化中设定的 **batch_size** 参数大于等于2）。
<br><br>
类的构造函数会进行数据加载工作，这可能需要很长的一段时间。当类 Au 被完全构建后，我们可以调用它的内置函数 **load_model** 来加载模型，我们需要指定参数：

| 参数 | 类型 | 默认值 | 说明 |
| --- | --- | --- | --- |
| modelName | str | - | 必填，需要调用或创建的模型完整名称（请注意，名称不需要指定路径，且模型名称需要以.pt后缀结尾） |
| model_type | str | - | 必填，模型类别，常用模型类别：背景抑制工作ResNet_custom、能量重建任务GoogLeNet、芯位坐标还原PointNet、和入射方向还原AngleNet (请注意，若您使用自定义模型，请严格确保按照规定的流程进行) |
| modelInit | bool | False | 指定模型是否进行初始化，如果您需要创建一个未经训练的模型参数，请将该参数设置为True （请注意，如果存在与 **modelName** 相同的文件，系统则会覆盖写入） |

此外，GPLearn支持使用自定义模型，但请严格按照如下步骤进行：<br>
1. 请确保您的自定义模型继承了 **torch.nn.Module** 类并且具有非重复的名字
2. 您需要在 **/model/__init__.py** 文件中添加引入来确保主函数可以正常访问
3. 若要使您的自定义模型可以被自动化训练类 **Au** 中被正常识别，您需要在 **/bin/modelInit.py** 文件中引入您的自定义模型，并且在模型选择选择语句中添加对应分支
4. 至此，您可以像使用预置模型那样使用您的自定义模型

在模型加载成功后，我们可以通过类内置函数 **train_step** 开展训练工作，并且可以自主设定训练过程的相应参数：

| 参数 | 类型 | 默认值 | 说明 |
| --- | --- | --- | --- |
| epoch_step_list | list | - | 必填，参数将以列表的形式传递，依次表示每一阶段所需要进行重复训练的次数 |
| lr_step_list | list | None | 可以传入一个列表来指定每一阶段的模型学习率（请注意，阶段学习率应该与阶段训练次数的长度相同，如不特别指定，则表示所有阶段按照6e-6的学习率进行） |

<br><br>
当然，对于测试任务，我们仅需要加载数据后并使用当前模型对结果进行测试即可，这可以使用类内置的 **test** 函数：<br>
该函数不需要传递任何参数，并会在执行过程中打印模型的测试结果。
<br><br>
最后，在我们的任务结束时，请调用类的析构函数 **finish** 来对生成的日志和数据进行保存。
<br><br>
至此，我们已经编辑完成了主程序的全部内容，您可以将当前项目部署在计算平台上。由于深度学习的训练往往是很久的，因此我们推荐使用 **nohup** 命令：<center> **nohup python main.py >> /dev/null 2>&1 &** </center>

这将在您的目标服务器上后台执行计算任务。<br>
请注意，对于一般的语法错误以及系统错误，**nohup** 命令可能会缺少相应的记录。因此，请确保您的模型可以成功运行后再进行托管。
<br><br>

### 辅助功能
无论您是在调试器中运行、**nohup** 托管运行、抑或是提交计算集群运行，我们开发了独立的日志模块用辅助于 **GPLearn** 的运行：无论程序运行在哪一步，您都可以访问指定的日志文件来查看当前程序运行中的所有输出。我们的日志文件存储在 **/data/log** 目录下，日志文件以执行程序时的时间戳命名，因此，您可以十分方便的定位到当前程序的日志文件。在日志的帮助下，您可以：<br>
1. 还原程序执行的主入口文件：日志将保存程序入口文件的全部代码，您可以轻松实现代码还原；
2. 还原程序执行的主要设置：日志将保存程序运行中所调用的所有位于 **settings.json** 中的设置，您可以轻松实现设置还原；
3. 查看程序运行的相关信息：日志会保存当前程序的版本号、运行进程ID、程序主入口路径等信息；
4. 查看训练任务及进展：日志会保存数据处理、模型加载、训练和测试过程中的所有输出信息，您可以查看加载数据集长度、模型信息、训练迭代损失、测试集结果以及对应的完成时间，这将对您的判断起重要参考作用；
5. 查看预计剩余时间：日志会根据之前的程序运行给出预计剩余时间与预计完成时间，作为您合理规划时间分配的依据。

在训练完成后，如果您记录了训练过程详细数据信息（通常为与日志文件同名的 **.data** 文件，位于 **/data/info** 目录下），您可以调用GPLearn内置的的画图程序包<center> **from bin.draw import \*** </center>

我们强烈建议您在Jupyter记事本中执行画图部分代码，程序最终的测试结果图可以通过 **result_genereation** 函数展示，函数仅需要传入相应的过程数据文件（ **.data** 文件）。<br>
当然，您可以自定义输出的图片样式，具体可以通过设定 **settings.json** 文件下的 **drawing -> result** 部分；对于不同训练任务的不同结果图，您可以分别作出如下设置：
| 关键字 | 默认值 | 说明 |
| ---  | --- | --- |
| title | - | 输出图表的标题，若设置了图片另存为，则会充当文件名字 |
| xlabel | - | 横坐标坐标轴标题 |
| ylabel | - | 纵坐标坐标轴标题 |
| label | Deep-Learning | 图线标题 |
| TeV_mode | false | 能量值是否以 **TeV** 为单位 |
| logX_mode | false | 横坐标是否以对数形式标注 |
| logY_mode | false | 纵坐标是否以对数形式标注 |
| color | null | 图线颜色 |
| save -> switch | false | 是否需要另存为图片 |
| save -> head_name | null | 另存为图片名字头 |
| save -> dpi | 400 | 另存为图片清晰度 |
